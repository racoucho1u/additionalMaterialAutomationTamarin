theory GDH begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman, multiset
functions: fst/1, pair/2, snd/1, te/1, te_inv/1
equations:
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    te_inv(te(x)) = x









restriction Unique:
  "∀ x #i #j. ((Uniq( x ) @ #i) ∧ (Uniq( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction Less1:
  "¬(∃ x #i. Less( x, x ) @ #i)"
  // safety formula

restriction Less2:
  "¬(∃ x y #i. Less( (x++y), x ) @ #i)"
  // safety formula

restriction InEq:
  "¬(∃ x #i. InEq( x, x ) @ #i)"
  // safety formula

rule (modulo E) AuthOut:
   [ !AO( A, x ) ] --> [ Out( x ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) CreateGroup:
   [ In( <'CreateGroup', $gid, k> ) ]
  --[ Uniq( <'CreateGroup', $gid> ), InEq( k, '1' ) ]->
   [ !Group( $gid, k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) StartParticipant:
   [ In( <'StartParticipant', $gid, i, $A> ), !Group( $gid, k ), Fr( ~esk )
   ]
  --[
  Uniq( <$gid, i> ), Uniq( <$gid, $A> ), Less( i, ('1'++k) ),
  Esk( $gid, i, ~esk )
  ]->
   [ !Pstate( $gid, i, $A, ~esk ), !Pmap( $gid, i, $A ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SendFirst:
   [ In( <'SendFirst', $gid> ), !Pstate( $gid, '1', $A, ~esk ) ]
  --[ Uniq( <'SendFirst', $gid> ), AExp( one ), AExp( ~esk ) ]->
   [
   !AO( $A, <$gid, ('1'++'1'), 'KeyFor', '1', 'g'> ),
   !AO( $A, <$gid, ('1'++'1'), 'RoundKey', 'g'^~esk> ),
   WaitAccept( $gid, '1', $A, ~esk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) RecvOthers:
   [
   In( <'RecvOthers', $gid, i, j> ), !Pstate( $gid, i, $A, ~esk ),
   !Pmap( $gid, l, $B ), !AO( $B, <$gid, i, 'KeyFor', j, 'g'^y> )
   ]
  --[
  Uniq( <'RecvOthers', $gid, i, j> ), Exp( $gid, i, y ),
  ExpKeyFor( $gid, i, j, y ), Eq( ('1'++l), i ), AExp( (~esk*y) ),
  AExp( y )
  ]->
   [ !AO( $A, <$gid, ('1'++i), 'KeyFor', j, 'g'^y^~esk> ) ]

  // loop breaker: [3]
  /*
  rule (modulo AC) RecvOthers:
     [
     In( <'RecvOthers', $gid, i, j> ), !Pstate( $gid, i, $A, ~esk ),
     !Pmap( $gid, l, $B ), !AO( $B, <$gid, i, 'KeyFor', j, z> )
     ]
    --[
    Uniq( <'RecvOthers', $gid, i, j> ), Exp( $gid, i, y ),
    ExpKeyFor( $gid, i, j, y ), Eq( ('1'++l), i ), AExp( (~esk*y) ),
    AExp( y )
    ]->
     [ !AO( $A, <$gid, ('1'++i), 'KeyFor', j, z.1> ) ]
    variants (modulo AC)
    1. ~esk  = ~esk.15
       y     = inv(~esk.15)
       z     = 'g'^inv(~esk.15)
       z.1   = 'g'
    
    2. ~esk  = ~esk.15
       y     = one
       z     = 'g'
       z.1   = 'g'^~esk.15
    
    3. ~esk  = ~esk.19
       y     = y.23
       z     = 'g'^y.23
       z.1   = 'g'^(~esk.19*y.23)
    
    4. ~esk  = ~esk.39
       y     = inv((~esk.39*x.73))
       z     = 'g'^inv((~esk.39*x.73))
       z.1   = 'g'^inv(x.73)
    
    5. ~esk  = ~esk.39
       y     = (x.73*inv(~esk.39))
       z     = 'g'^(x.73*inv(~esk.39))
       z.1   = 'g'^x.73
    
    6. ~esk  = ~esk.40
       y     = (x.74*inv((~esk.40*x.75)))
       z     = 'g'^(x.74*inv((~esk.40*x.75)))
       z.1   = 'g'^(x.74*inv(x.75))
    // loop breaker: [3]
  */

rule (modulo E) RecvRoundkey:
   [
   In( <'RecvRoundkey', $gid, i> ), !Pstate( $gid, i, $A, ~esk ),
   !Pmap( $gid, l, $B ), !Group( $gid, k ),
   !AO( $B, <$gid, i, 'RoundKey', 'g'^y> )
   ]
  --[
  Uniq( <'RecvRoundkey', $gid, i> ), InEq( i, k ), Eq( ('1'++l), i ),
  Exp( $gid, i, y ), ExpRoundKey( $gid, i, y ), AExp( y ), AExp( (~esk*y) )
  ]->
   [
   !AO( $A, <$gid, ('1'++i), 'KeyFor', i, 'g'^y> ),
   !AO( $A, <$gid, ('1'++i), 'RoundKey', 'g'^y^~esk> ),
   WaitAccept( $gid, i, $A, ~esk )
   ]

  // loop breaker: [4]
  /*
  rule (modulo AC) RecvRoundkey:
     [
     In( <'RecvRoundkey', $gid, i> ), !Pstate( $gid, i, $A, ~esk ),
     !Pmap( $gid, l, $B ), !Group( $gid, k ),
     !AO( $B, <$gid, i, 'RoundKey', z> )
     ]
    --[
    Uniq( <'RecvRoundkey', $gid, i> ), InEq( i, k ), Eq( ('1'++l), i ),
    Exp( $gid, i, y ), ExpRoundKey( $gid, i, y ), AExp( y ), AExp( (~esk*y) )
    ]->
     [
     !AO( $A, <$gid, ('1'++i), 'KeyFor', i, z> ),
     !AO( $A, <$gid, ('1'++i), 'RoundKey', z.1> ),
     WaitAccept( $gid, i, $A, ~esk )
     ]
    variants (modulo AC)
    1. ~esk  = ~esk.16
       y     = inv(~esk.16)
       z     = 'g'^inv(~esk.16)
       z.1   = 'g'
    
    2. ~esk  = ~esk.16
       y     = one
       z     = 'g'
       z.1   = 'g'^~esk.16
    
    3. ~esk  = ~esk.20
       y     = y.24
       z     = 'g'^y.24
       z.1   = 'g'^(~esk.20*y.24)
    
    4. ~esk  = ~esk.53
       y     = inv((~esk.53*x.101))
       z     = 'g'^inv((~esk.53*x.101))
       z.1   = 'g'^inv(x.101)
    
    5. ~esk  = ~esk.53
       y     = (x.101*inv(~esk.53))
       z     = 'g'^(x.101*inv(~esk.53))
       z.1   = 'g'^x.101
    
    6. ~esk  = ~esk.54
       y     = (x.102*inv((~esk.54*x.103)))
       z     = 'g'^(x.102*inv((~esk.54*x.103)))
       z.1   = 'g'^(x.102*inv(x.103))
    // loop breaker: [4]
  */

rule (modulo E) RecvRoundkeyLast:
   [
   In( <'RecvRoundkeyLast', $gid> ), !Pstate( $gid, k, $A, ~esk ),
   !Pmap( $gid, l, $B ), !Group( $gid, k ),
   !AO( $B, <$gid, k, 'RoundKey', 'g'^y> )
   ]
  --[
  Uniq( <'RecvRoundkeyLast', $gid> ), Exp( $gid, k, y ), Eq( ('1'++l), k ),
  AcceptLast( $gid, $A, k, 'g'^y^~esk ), ExpRoundKey( $gid, k, y ),
  AExp( y )
  ]->
   [ ]

  /*
  rule (modulo AC) RecvRoundkeyLast:
     [
     In( <'RecvRoundkeyLast', $gid> ), !Pstate( $gid, k, $A, ~esk ),
     !Pmap( $gid, l, $B ), !Group( $gid, k ),
     !AO( $B, <$gid, k, 'RoundKey', z> )
     ]
    --[
    Uniq( <'RecvRoundkeyLast', $gid> ), Exp( $gid, k, y ), Eq( ('1'++l), k ),
    AcceptLast( $gid, $A, k, z.1 ), ExpRoundKey( $gid, k, y ), AExp( y )
    ]->
     [ ]
    variants (modulo AC)
    1. ~esk  = ~esk.14
       y     = inv(~esk.14)
       z     = 'g'^inv(~esk.14)
       z.1   = 'g'
    
    2. ~esk  = ~esk.14
       y     = one
       z     = 'g'
       z.1   = 'g'^~esk.14
    
    3. ~esk  = ~esk.17
       y     = y.20
       z     = 'g'^y.20
       z.1   = 'g'^(~esk.17*y.20)
    
    4. ~esk  = ~esk.35
       y     = inv((~esk.35*x.65))
       z     = 'g'^inv((~esk.35*x.65))
       z.1   = 'g'^inv(x.65)
    
    5. ~esk  = ~esk.35
       y     = (x.65*inv(~esk.35))
       z     = 'g'^(x.65*inv(~esk.35))
       z.1   = 'g'^x.65
    
    6. ~esk  = ~esk.36
       y     = (x.66*inv((~esk.36*x.67)))
       z     = 'g'^(x.66*inv((~esk.36*x.67)))
       z.1   = 'g'^(x.66*inv(x.67))
  */

rule (modulo E) Accept:
   [
   In( <'Accept', $gid, i> ), WaitAccept( $gid, i, $A, ~esk ),
   !Group( $gid, k ), !Pmap( $gid, k, $B ),
   !AO( $B, <$gid, ('1'++k), 'KeyFor', i, 'g'^y> )
   ]
  --[
  Accept( $gid, $A, i, 'g'^y^~esk ), Uniq( <'Accept', $gid, i> ),
  Exp( $gid, ('1'++k), y ), AExp( y )
  ]->
   [ ]

  /*
  rule (modulo AC) Accept:
     [
     In( <'Accept', $gid, i> ), WaitAccept( $gid, i, $A, ~esk ),
     !Group( $gid, k ), !Pmap( $gid, k, $B ),
     !AO( $B, <$gid, ('1'++k), 'KeyFor', i, z> )
     ]
    --[
    Accept( $gid, $A, i, z.1 ), Uniq( <'Accept', $gid, i> ),
    Exp( $gid, ('1'++k), y ), AExp( y )
    ]->
     [ ]
    variants (modulo AC)
    1. ~esk  = ~esk.14
       y     = inv(~esk.14)
       z     = 'g'^inv(~esk.14)
       z.1   = 'g'
    
    2. ~esk  = ~esk.14
       y     = one
       z     = 'g'
       z.1   = 'g'^~esk.14
    
    3. ~esk  = ~esk.17
       y     = y.20
       z     = 'g'^y.20
       z.1   = 'g'^(~esk.17*y.20)
    
    4. ~esk  = ~esk.35
       y     = inv((~esk.35*x.65))
       z     = 'g'^inv((~esk.35*x.65))
       z.1   = 'g'^inv(x.65)
    
    5. ~esk  = ~esk.35
       y     = (x.65*inv(~esk.35))
       z     = 'g'^(x.65*inv(~esk.35))
       z.1   = 'g'^x.65
    
    6. ~esk  = ~esk.36
       y     = (x.66*inv((~esk.36*x.67)))
       z     = 'g'^(x.66*inv((~esk.36*x.67)))
       z.1   = 'g'^(x.66*inv(x.67))
  */

lemma No_Inv_exp [use_induction, reuse, sources]:
  all-traces
  "¬((∃ #i x. AExp( inv(x) ) @ #i) ∨ (∃ #i x y. AExp( (x*inv(y)) ) @ #i))"
/*
guarded formula characterizing all counter-examples:
"((∃ #i x. (AExp( inv(x) ) @ #i)) ∨
  (∃ #i x y. (AExp( (x*inv(y)) ) @ #i)))"
*/
by sorry

lemma Esk_secret [reuse]:
  all-traces
  "¬(∃ #i #j gid x r. (!KU( x ) @ #i) ∧ (Esk( gid, r, x ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j gid x r. (!KU( x ) @ #i) ∧ (Esk( gid, r, x ) @ #j)"
*/
by sorry

lemma Esk_fresh_name [reuse]:
  all-traces "∀ #i x r gid. (Esk( gid, r, x ) @ #i) ⇒ (∃ ~n. x = ~n)"
/*
guarded formula characterizing all counter-examples:
"∃ #i x r gid. (Esk( gid, r, x ) @ #i) ∧ ∀ ~n. (x = ~n) ⇒ ⊥"
*/
by sorry

lemma ExpKeyFor_one [reuse]:
  all-traces
  "∀ #v i r gid.
    (ExpKeyFor( gid, r, i, one ) @ #v) ⇒ ((i = '1') ∧ (r = ('1'++'1')))"
/*
guarded formula characterizing all counter-examples:
"∃ #v i r gid.
  (ExpKeyFor( gid, r, i, one ) @ #v)
 ∧
  ((¬(i = '1')) ∨ (¬(r = ('1'++'1'))))"
*/
by sorry

lemma Relate_KeyFor_RoundKey [reuse, hide_lemma=Exp_earlier_Esk,
                              use_induction]:
  all-traces
  "∀ #v1 #v2 gid r j ej e.
    ((ExpKeyFor( gid, r, j, ej ) @ #v1) ∧ (ExpRoundKey( gid, r, e ) @ #v2)) ⇒
    ((∃ #v3 xj. (Esk( gid, j, xj ) @ #v3) ∧ ((ej*xj) = e)) ∨ (ej = one))"
/*
guarded formula characterizing all counter-examples:
"∃ #v1 #v2 gid r j ej e.
  (ExpKeyFor( gid, r, j, ej ) @ #v1) ∧ (ExpRoundKey( gid, r, e ) @ #v2)
 ∧
  (∀ #v3 xj. (Esk( gid, j, xj ) @ #v3) ∧ ((ej*xj) = e) ⇒ ⊥) ∧
  (¬(ej = one))"
*/
by sorry

lemma Exp_subterm [use_induction, reuse]:
  all-traces
  "¬(∃ gid r i j e x #v1 #v2.
      (ExpKeyFor( gid, ('1'++r), j, e ) @ #v1) ∧
      (ExpKeyFor( gid, ('1'++r), i, (e*x) ) @ #v2))"
/*
guarded formula characterizing all counter-examples:
"∃ gid r i j e x #v1 #v2.
  (ExpKeyFor( gid, ('1'++r), j, e ) @ #v1) ∧
  (ExpKeyFor( gid, ('1'++r), i, (e*x) ) @ #v2)"
*/
by sorry

lemma Exp_earlier_Esk [use_induction, reuse,
                       hide_lemma=Relate_KeyFor_RoundKey]:
  all-traces
  "∀ #i x ~n r1 gid.
    (Exp( gid, r1, (~n*x) ) @ #i) ⇒
    (∃ r2 r3 #j. (Esk( gid, r2, ~n ) @ #j) ∧ (r1 = (r2++r3)))"
/*
guarded formula characterizing all counter-examples:
"∃ #i x ~n r1 gid.
  (Exp( gid, r1, (~n*x) ) @ #i)
 ∧
  ∀ r2 r3 #j. (Esk( gid, r2, ~n ) @ #j) ∧ (r1 = (r2++r3)) ⇒ ⊥"
*/
by sorry

lemma Exp_earlier_Esk_2 [reuse, hide_lemma=Relate_KeyFor_RoundKey]:
  all-traces
  "∀ #i #j gid x n r1 r2.
    ((Exp( gid, r2, (n*x) ) @ #i) ∧ (Esk( gid, r1, n ) @ #j)) ⇒
    (∃ r3. r2 = (r1++r3))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j gid x n r1 r2.
  (Exp( gid, r2, (n*x) ) @ #i) ∧ (Esk( gid, r1, n ) @ #j)
 ∧
  ∀ r3. (r2 = (r1++r3)) ⇒ ⊥"
*/
by sorry

lemma roundkey_keyfor_different [use_induction, reuse,
                                 hide_lemma=Exp_earlier_Esk, hide_lemma=Relate_KeyFor_RoundKey]:
  all-traces
  "¬(∃ #i #j gid r1 i.1 y.
      (ExpKeyFor( gid, r1, i.1, y ) @ #i) ∧ (ExpRoundKey( gid, r1, y ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j gid r1 i.1 y.
  (ExpKeyFor( gid, r1, i.1, y ) @ #i) ∧ (ExpRoundKey( gid, r1, y ) @ #j)"
*/
by sorry

lemma Exp_nonce_or_product2 [use_induction, reuse,
                             hide_lemma=Exp_earlier_Esk, hide_lemma=Relate_KeyFor_RoundKey]:
  all-traces
  "∀ #i j x z gid.
    (Exp( gid, j, (x*z) ) @ #i) ⇒
    ((∃ #j.1 r. Esk( gid, r, x ) @ #j.1) ∨
     (∃ #j.1 ~n r. (Esk( gid, r, ~n ) @ #j.1) ∧ (∃ y. x = (~n*y))))"
/*
guarded formula characterizing all counter-examples:
"∃ #i j x z gid.
  (Exp( gid, j, (x*z) ) @ #i)
 ∧
  (∀ #j.1 r. (Esk( gid, r, x ) @ #j.1) ⇒ ⊥) ∧
  (∀ #j.1 ~n r. (Esk( gid, r, ~n ) @ #j.1) ⇒ ∀ y. (x = (~n*y)) ⇒ ⊥)"
*/
by sorry

lemma Exp_factor_secret [reuse, hide_lemma=Exp_earlier_Esk,
                         hide_lemma=Relate_KeyFor_RoundKey]:
  all-traces
  "¬(∃ #v1 #v2 i x y gid. (Exp( gid, i, (x*y) ) @ #v1) ∧ (!KU( x ) @ #v2))"
/*
guarded formula characterizing all counter-examples:
"∃ #v1 #v2 i x y gid. (Exp( gid, i, (x*y) ) @ #v1) ∧ (!KU( x ) @ #v2)"
*/
simplify
solve( (∃ #j r. (Esk( gid, r, x ) @ #j))  ∥
       (∃ #j ~n r. (Esk( gid, r, ~n ) @ #j) ∧ ∃ y. (x = (~n*y))) )
  case case_1
  by contradiction /* from formulas */
next
  case case_2
  by contradiction /* from formulas */
qed

lemma Exp_name_secret [reuse, hide_lemma=Exp_earlier_Esk,
                       hide_lemma=Relate_KeyFor_RoundKey]:
  all-traces
  "¬(∃ #v1 #v2 i ~x gid. (Exp( gid, i, ~x ) @ #v1) ∧ (!KU( ~x ) @ #v2))"
/*
guarded formula characterizing all counter-examples:
"∃ #v1 #v2 i ~x gid. (Exp( gid, i, ~x ) @ #v1) ∧ (!KU( ~x ) @ #v2)"
*/
by sorry

lemma Esk_Exp_same_gid [hide_lemma=Exp_earlier_Esk, reuse, use_induction,
                        hide_lemma=Relate_KeyFor_RoundKey]:
  all-traces
  "∀ gid1 gid2 i j x e #v1 #v2.
    ((Esk( gid1, i, x ) @ #v1) ∧ (Exp( gid2, j, (e*x) ) @ #v2)) ⇒
    (gid1 = gid2)"
/*
guarded formula characterizing all counter-examples:
"∃ gid1 gid2 i j x e #v1 #v2.
  (Esk( gid1, i, x ) @ #v1) ∧ (Exp( gid2, j, (e*x) ) @ #v2)
 ∧
  ¬(gid1 = gid2)"
*/
by sorry

lemma key_secret_last [hide_lemma=Exp_earlier_Esk,
                       hide_lemma=Exp_nonce_or_product2, hide_lemma=Relate_KeyFor_RoundKey]:
  all-traces
  "¬(∃ gid A i key #i1 #i2.
      (AcceptLast( gid, A, i, key ) @ #i1) ∧ (!KU( key ) @ #i2))"
/*
guarded formula characterizing all counter-examples:
"∃ gid A i key #i1 #i2.
  (AcceptLast( gid, A, i, key ) @ #i1) ∧ (!KU( key ) @ #i2)"
*/
by sorry

lemma key_secret [hide_lemma=Exp_earlier_Esk,
                  hide_lemma=Exp_nonce_or_product2, hide_lemma=Relate_KeyFor_RoundKey]:
  all-traces
  "¬(∃ gid A i key #i1 #i2.
      (Accept( gid, A, i, key ) @ #i1) ∧ (!KU( key ) @ #i2))"
/*
guarded formula characterizing all counter-examples:
"∃ gid A i key #i1 #i2.
  (Accept( gid, A, i, key ) @ #i1) ∧ (!KU( key ) @ #i2)"
*/
by sorry











/*
WARNING: the following wellformedness checks failed!

Formula terms
=============

  Lemma `No_Inv_exp' uses terms of the wrong form: `inv(Bound 0)',
    `Mult(Bound 1,inv(Bound 0))'
  
  The only allowed terms are public constants and bound node and
  message variables. If you encounter free message variables, then
  you might have forgotten a #-prefix. Sort prefixes can only be
  dropped where this is unambiguous. Moreover, reducible function
  symbols are disallowed.

Quantifier sorts
================

  Lemma `Esk_fresh_name' uses quantifiers with wrong sort:
    ("n",LSortFresh)
  
  Lemma `Exp_earlier_Esk' uses quantifiers with wrong sort:
    ("n",LSortFresh)
  
  Lemma `Exp_nonce_or_product2' uses quantifiers with wrong sort:
    ("n",LSortFresh)
  
  Lemma `Exp_name_secret' uses quantifiers with wrong sort:
    ("x",LSortFresh)

Message Derivation Checks
=========================

  The variables of the following rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule RecvOthers: 
Failed to derive Variable(s): y

Rule RecvRoundkey: 
Failed to derive Variable(s): y

Rule RecvRoundkeyLast: 
Failed to derive Variable(s): y

Rule Accept: 
Failed to derive Variable(s): y
*/

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.2 (unsupported)
Git revision: 969dfd42c08c2ce22a167f070680cf392570fedf (with uncommited changes), branch: develop
Compiled at: 2025-02-18 09:44:08.195281873 UTC
*/

end